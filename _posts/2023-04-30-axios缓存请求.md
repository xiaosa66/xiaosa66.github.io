### 第一版代码

```js
import axios from 'axios'
import LRUCache from 'lru-cache'
const cache = new LRUCache({
    max: 100,
    maxAge: 10000
  });
  const useCache = config => {
    if (!config?.useCache) return config;
    // 生成缓存key
    const cacheKey = getCacheKey(config);
    // 如果缓存中有结果，则直接返回缓存结果
    const cachedResponse = cache.get(cacheKey);
    if (cachedResponse) {
      let source = axios.CancelToken.source();
      config.cancelToken = source.token;
      // @ts-ignore
      source.cancel({type: 'hit cache', data: cachedResponse})
    }
    return config;
  }
  const setCache = (response) => {
    if (!response?.config?.useCache) return response;
    console.log('resp12312312', response)
    if (response?.hitCache) {
      console.log('response123123', response)
      return response;
    }
    // 生成缓存key
    const cacheKey = getCacheKey(response.config);
    // 缓存结果
    cache.set(cacheKey, response.data);
    console.log('cacheKey setCache', cacheKey)
    console.log('cache.keys', cache)
    return response;
  }
  
  axios.interceptors.request.use(useCache);
  axios.interceptors.response.use(setCache);
  ```

上述代码可以缓存请求 但是在实际场景中存在一个致命的问题。
实际场景：在main.js 中提前发起阻塞性请求，避免业务中世纪请求时阻塞页面渲染。
而预请求的时候往往请求还没结束 就开始真正的业务请求了，这时候预请求没有结束导致缓存还没写入，就会再次发起请求，反而导致了性能的浪费。
所以希望缓存的是一个promise，这个promise在请求开始时就写入缓存，并在请求结束后settled。当第二次请求时，如果缓存中有这个promise，就直接返回这个promise，而不是再次发起请求。

### 第二版代码

```js
import axios from 'axios';
import LRUCache from 'lru-cache';

const cache = new LRUCache({
  max: 100,
  maxAge: 10000
});

const useCache = config => {
  if (!config?.useCache) return config;

  const cacheKey = getCacheKey(config);

  const cachedResponse = cache.get(cacheKey);

  if (cachedResponse) {
    if (cachedResponse instanceof Promise) {
      return cachedResponse.then(response => {
        response.hitCache = true;
        return response;
      });
    }

    let source = axios.CancelToken.source();
    config.cancelToken = source.token;
    source.cancel({ type: 'hit cache', data: cachedResponse });
  } else {
    const pendingPromise = cache.get(cacheKey + ':pending');

    if (pendingPromise) {
      return pendingPromise;
    }

    const pending = axios(config).then(response => {
      setCache(response);
      return response;
    });

    cache.set(cacheKey + ':pending', pending);

    return pending;
  }

  return config;
};

const setCache = response => {
  if (!response?.config?.useCache) return response;

  const cacheKey = getCacheKey(response.config);

  cache.del(cacheKey + ':pending');

  cache.set(cacheKey, response.data);

  return response;
};

const getCacheKey = config => {
  return JSON.stringify({
    method: config.method,
    url: config.url,
    params: config.params,
    data: config.data
  });
};

axios.interceptors.request.use(useCache);
axios.interceptors.response.use(setCache);
```


注：写完以后才发现虽然axios官方没有提供这个功能 但社区已经有人实现了：https://www.npmjs.com/package/axios-cache-adapter