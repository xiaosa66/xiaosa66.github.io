##  1 模板编译

  ### 需求 : 使用 render 函数 让 jsx 与 dom 绑定
  我们先来一个render函数:
  
```js
function render(jsx, domMounter) {
     let builtDOM = domBuilder(jsx);
        domMounter.appendChild(builtDOM);
    return builtDOM;
}
```
熟悉react的同学都知道 , 我们向render函数传入的两个参数就是 jsx 与 dom 挂载点

在 render 函数中 我们主要调用了 domBuilder 函数


```js
function domBuilder(vNode) {
    if (typeof vNode === 'string') {
        return document.createTextNode(vNode);
    }
    let { nodeName, attributes: attrs, children } = vNode;
    if (typeof nodeName === 'string') {
        let node = document.createElement(nodeName);
        if (attrs) {
            for (let key in attrs) {
                if (!attrs.hasOwnProperty(key)) continue;  // todo 使用 object.create(null) 以省略此句
                 node.setAttribute(key, attrs[key]); // 设置 dom 节点的属性
            }
        }
        // 递归调用
        if (children) {
            children.forEach(childVNode => {
                let subNode = domBuilder(childVNode);
                node.appendChild(subNode);
            });
        }
        return node;
    }
}
```

我们看到 domBuilder 主要是进行 vNode 的处理, 这里我们需要了解vNode的构造

```js
class VNode {
    constructor(nodeName, attributes, children) {
        this.nodeName = nodeName;
        this.attributes = attributes;
        this.children = children;
    }
}

declare type VNode<P> = {
    nodeName: string | Function,
    children: Array<VNode<P>,
    attributes: P,
    //key?: string | number | void,   //   为了diff的优化 这里可以先不用
};

```

其中的children,是其他的子孙vNode,其实vNode是一个树型的结构,他是为了描述dom结构,dom我们都知道他是树形的.


通过 webpack 编译 jsx 调用自己编写的 h 函数 返回 vNode ,为什么叫做 h 函数呢,这是约定俗成的.

```js
function h(nodeName, attributes, ...args) {
  //对children进行处理 ,把args放到数组里封装成children
    let children = args.length ? [].concat(...args) : null;
    return new VNode(nodeName, attributes, children);
}

```
 
 有了这些函数以后  我们就能执行最基本的功能,即通过编写 jsx 生成真实dom并挂载到网页上.


## 2 组件编译 

这里我们新建一个组件类 

```js
class Component {
    constructor() {
        this.props = {};
        this.nextProps = {};
        this.state = {};
    }

    setState(state) {
        extend(this.state, state);
        renderComponent(this);
    }

    render(props) {
        return h('div', null, props.children);
    }

    shouldComponentUpdate(props, state) {
        return true;
    }
}
```

加上 component 以后, 就要考虑 domBuilder 函数在处理 component 时的情况

```diff
+   function domBuilder(vNode,dom) {
        if (typeof vNode === 'string') {
            return document.createTextNode(vNode);
        }
        let { nodeName, attributes: attrs, children } = vNode;

+       if (typeof nodeName === 'function') {
+            return cDomBuilder(vNode, dom);
+        }
......

```

在这里  我们判断如果node为component,执行另外一个方法 cDomBuilder

可以看到代码上 判断 typeof nodeName === 'function'   
即可知道node为component,这是因为bable解析jsx时 组件的nodeName传的是组件类 

```javascript
function cDomBuilder(vNode, dom) {
    if (dom && dom._component) {
        setComponentProps(dom._component, getNodeProps(vNode)); // 组件的props 相当于 普通标签的attrs
        cRender(dom._component); //  在设置 props 之后重新渲染组件
    } else {
        dom = createComponentFromVNode(vNode);
    }
    return dom;
}

function getNodeProps(vNode) {
    return {...vNode.attributes};
}

/**
 * 由 vNode 生成 base 真实 DOM；
 * 注意与 buildComponentFromVNode 的区别
 * @param vNode
 * @returns {DOM|*}
 */
function createComponentFromVNode(vNode) {
    let component = new vNode.nodeName();
    let props = getNodeProps(vNode);
    setComponentProps(component, props);
    cRender(component);
    return component.base;
}

```

这个函数实际上执行了另外两个方法 




```js
/**
 * 把最新的 props 覆盖 nextProps
 * @param {Component} component 组件
 * @param {Object} props 新的props
 */
function setComponentProps(component, props) {
    // hook(component, 'componentWillReceiveProps', props, component.props)

    component.nextProps = props;
}


/**
 * 组件渲染主体逻辑
 * ① 生成新的 vNode → renderedVNode
 * ② 构建出新的 DOM → base
 * ③ 挂载到 base 上
 * nextProps setState之后的值
 * props setState之前的值
 * @param {Component} component 组件
 */
function cRender(component) {
    let p = component.nextProps;
    let s = component.state;
    if (component.base) {  // 非首次渲染
        执行一些优化操作
    }
    // component.props = p;
    let renderedVNode = hook(component, 'render', p, s); // 执行组件内部钩子函数
    let base = domBuilder(renderedVNode, component.base);
    if (base) {
        component.base = base;
        component.base._component = component;
    }
    return base;
}
```


在这里需要说明一下说明一下 hook 函数  

```js
function hook(obj, name, ...args) {
    let fn = obj[name];
    if (fn && typeof fn === 'function') {
        console.log('即将执行'+name+'函数')
        return fn.apply(obj, args); // 通过apply改变fn的this指针的指向为obj,并为fn传入args参数
    } else {
        console.error('生命周期函数'+name+'不存在')
    }
}
```

我们通过hook函数调用了component里的render函数  实际上,以后我们会不断调用hook函数来执行组件的生命周期函数


# 待续
```js

```