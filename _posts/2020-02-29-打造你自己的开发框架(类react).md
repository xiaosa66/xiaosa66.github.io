##  1 模板编译

 - 需求 : 使用 render 函数 让 jsx 与 dom 绑定
 - 实现 :
```ts
function render(vNode, parent) {
     let builtDOM = buildDOMByVNode(vNode);
        parent.appendChild(builtDOM);
    return builtDOM;
}

```
在 render 函数中 我们主要调用了 buildDOMByVNode 函数
```js
function buildDOMByVNode(vNode) {
    if (typeof vNode === 'string') {
        return document.createTextNode(vNode);
    }
    let { nodeName, attributes: attrs, children } = vNode;
    if (typeof nodeName === 'string') {
        let node = document.createElement(nodeName);
        if (attrs) {
            for (let key in attrs) {
                // todo 使用 object.create(null) 以省略下一句
                if (!attrs.hasOwnProperty(key)) continue;
                 node.setAttribute(key, attrs[key]);
            }
        }
        // 递归调用
        if (children) {
            children.forEach(child => {
                let subNode = buildDOMByVNode(child);
                node.appendChild(subNode);
            });
        }
        return node;
    }
}
```

我们看到 buildDOMByVNode 主要是进行 vNode 的处理,这里我们需要了解vNode的构造

```js
class VNode {
    constructor(nodeName, attributes, children) {
        this.nodeName = nodeName;
        this.attributes = attributes;
        this.children = children;
    }
}

declare type VNode<P> = {
    nodeName: string | Function,
    children: Array<VNode<P>,
    attributes: P,
    //key?: string | number | void, 为了diff的优化 这里可以先不用
};

```

其中的children,是其他的子孙vNode,其实vNode是一个树型的结构,他是为了描述dom结构,dom我们都知道他是树形的.


通过 webpack 编译 jsx 调用自己编写的 h 函数 返回 vNode ,为什么叫做 h 函数呢,这是约定俗成的.

```js
function h(nodeName, attributes, ...args) {
  //对children进行处理 ,把args放到数组里封装成children
    let children = args.length ? [].concat(...args) : null;
    return new VNode(nodeName, attributes, children);
}

```



# 待续